---
title: "Data Formatting for Sex Covariate"
output: html_document
date: "2025-01-21"
---

```{r}

library(tidyverse)
library(rstan)
library(cmdstanr)
library(data.table)
library(mrmrmr)

captures <- read.csv("/Users/johnimperato/Documents/private_MP_data/captures_MP.csv")

full_captures <- read.csv("/Users/johnimperato/Desktop/Mossy-Pond_companion/Capture_Data.csv")

surveys <- read.csv("/Users/johnimperato/Desktop/Mossy-Pond/data/survey_MossyPond.csv")

```

## Data Formatting

### Clean up frog sex data

Resolve inconsistencies in frog_sex column. For frogs with multiple sexes listed over multiple captures, use the most recent observation. If the most recent observation is blank, use the most common sex identification.

```{r}

# Load the full capture data set
capture_data_full <- read.csv("/Users/johnimperato/Desktop/Mossy-Pond_companion/Capture_Data.csv")

# Select relevant columns, remove duplicates, and arrange by PIT tag
capture_data_full <- capture_data_full %>% 
  select(Date, PIT_TagCode, frog_sex) %>% 
  unique() %>% 
  arrange(PIT_TagCode)

# Clean up the Date column (remove time and convert to Date format)
capture_data_full$Date <- gsub("00:00:00 EDT", "", capture_data_full$Date)
capture_data_full$Date <- as.Date(capture_data_full$Date, format = "%a %b %d %Y")

# Write function to resolve the frog)_sex, taking the most recent, or the most common non-empty sex identification if the most recent is empty
resolve_sex <- function(data) {
  # Check if there's any non-empty sex data
  non_empty_data <- data %>% filter(frog_sex != "")
  
  if (nrow(non_empty_data) == 0) {
    return(NA)  # Return NA if no valid sex is found
  }
  
  # Find the most recent sex
  most_recent <- data %>% filter(Date == max(Date)) %>% pull(frog_sex)
  
  if (most_recent != "") {
    return(most_recent)
  } else {
    # If most recent sex is empty, return the most common non-empty sex
    return(non_empty_data %>% 
             count(frog_sex) %>% 
             slice_max(n, n = 1) %>% 
             pull(frog_sex))
  }
}

# Apply the function to resolve the sex for each frog
resolved_sex_data <- capture_data_full %>%
  group_by(PIT_TagCode) %>%
  group_modify(~ mutate(.x, Sex_resolved = resolve_sex(.x))) %>%
  ungroup() %>% 
  select(PIT_TagCode, Sex_resolved) %>% 
  unique() %>% 
  rename(sex = Sex_resolved)%>%
  mutate(sex_binary = ifelse(sex == "M", 1, ifelse(sex == "F", 0, NA))) %>% 
  filter(!is.na(sex) & sex != "U") %>% 
  rename(pit_tag_id = PIT_TagCode)

# compoute observed sex ratio
sex_ratio <- resolved_sex_data %>% 
  count(sex) %>% 
  mutate(prop = n / sum(n))

```

### Join sex data with capture data

```{r}

captures <- captures %>% 
  left_join(resolved_sex_data,
            by = "pit_tag_id")

write.csv(captures, "/Users/johnimperato/Desktop/Mossy-Pond_companion/MP_caps_sex.csv")

```

### Run updated clean_data function 

1 = female, 2 = male

Fill in survival sex values according to observed sex ratio

```{r}    

data <- mrmr::clean_data(captures = captures,
                              surveys = surveys,
                              survival_formula = ~ sex,
                              survival_fill_value = c(sex = "MISSING"))

# index individuals with NA sex value
missing_idx <- which(is.na(data$survival_covariate_df$sex) |
                     data$survival_covariate_df$sex == "MISSING" |
                     data$survival_covariate_df$sex == "")
# replace NA values with a sample of sex assignments with probability derived from the observed data 
if(length(missing_idx) > 0) {
  data$survival_covariate_df$sex[missing_idx] <- sample(
    sex_ratio$sex,
    size = length(missing_idx),
    replace = TRUE,
    prob = sex_ratio$prop
  )
}



```

```{r}

mod_sex <- mrmrmr::fit_model_TVD(
  data = data,
  chains = 3,
  iter_warmup = 1000,
  iter_sampling = 1000,
  parallel_chains = 4,
  threads_per_chain = 2
)

modsex_summary <- mod_sex$m_fit$summary()
View(modsex_summary)

saveRDS(mod_sex, "/Users/johnimperato/Desktop/Mossy-Pond_companion/sex_survival_covariate_model_4.rds")

```




